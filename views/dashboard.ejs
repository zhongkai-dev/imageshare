<!-- Custom CSS overrides -->
<style>
  .navbar-brand {
    margin-right: 0 !important;
    padding-right: 0 !important;
  }
  .navbar-logo {
    margin-right: 0 !important;
  }
  .dev-label {
    margin-left: 6px !important;
    padding-left: 0 !important;
    background-color: transparent !important;
    border-radius: 0 !important;
    color: #4e73df !important;
    font-weight: 500 !important;
  }
  .navbar-left {
    gap: 0 !important;
  }
  
  .image-grid-item {
    position: relative;
  }
  
  .image-preview {
    position: relative;
  }
  
  /* Add styling for file info area */
  .file-info {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }
  
  .file-info > div:first-child {
    margin-bottom: 0.25rem;
  }
  
  /* Button spacing */
  .file-info .btn {
    margin-right: 0.5rem;
    margin-bottom: 0.25rem;
  }
  
  /* Styles for extracted phone numbers list */
  .extracted-numbers {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    align-items: center;
  }
  
  .phone-number-item {
    display: flex;
    align-items: center;
    background-color: #f0f8ff;
    border: 1px solid #cce5ff;
    border-radius: 4px;
    padding: 2px 8px;
    font-size: 0.9rem;
  }
  
  .phone-number-item .copy-number-btn {
    border: none;
    background: transparent;
    color: #4e73df;
    padding: 2px 5px;
    margin-left: 6px;
    cursor: pointer;
    border-radius: 3px;
  }
  
  .phone-number-item .copy-number-btn:hover {
    background-color: rgba(78, 115, 223, 0.1);
  }
  
  .phone-number-loading {
    display: flex;
    align-items: center;
  }
  
  .image-paste-preview {
    background-color: rgba(0,0,0,0.03);
    border-radius: 8px;
    padding: 10px;
    margin-top: 10px;
    max-height: 200px;
    overflow-y: auto;
  }
  
  .preview-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
    gap: 8px;
  }
  
  .preview-item {
    position: relative;
    width: 80px;
    height: 80px;
    border-radius: 4px;
    overflow: hidden;
  }
  
  .preview-item img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }
  
  .preview-item .remove-btn {
    position: absolute;
    top: 2px;
    right: 2px;
    background: rgba(0,0,0,0.5);
    color: white;
    border: none;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    font-size: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
  }
  
  /* Message input styles for textarea */
  .message-input-container {
    position: relative;
    flex-grow: 1;
    display: flex;
  }
  
  .message-input {
    border-radius: 20px;
    padding: 10px 40px 10px 15px;
    resize: none;
    overflow-y: auto;
    max-height: 120px;
    min-height: 42px;
    line-height: 1.5;
  }
  
  .input-actions {
    position: absolute;
    right: 12px;
    top: 50%;
    transform: translateY(-50%);
    display: flex;
    align-items: center;
  }
  
  /* Custom text selection color for message input */
  .message-input::selection {
    background-color: rgba(78, 115, 223, 0.3); /* Light blue color */
    color: inherit;
  }
  
  /* For Firefox */
  .message-input::-moz-selection {
    background-color: rgba(78, 115, 223, 0.3); /* Light blue color */
    color: inherit;
  }
  
  /* Keyboard shortcuts hint styling */
  .keyboard-shortcuts-hint {
    font-size: 0.75rem;
    opacity: 0.7;
    padding-left: 12px;
  }
  
  .keyboard-shortcuts-hint strong {
    background-color: rgba(78, 115, 223, 0.1);
    padding: 1px 4px;
    border-radius: 3px;
    font-weight: 600;
  }
</style>

<!-- Navbar -->
<nav class="navbar navbar-expand-lg navbar-light bg-white shadow-sm fixed-top">
  <div class="container">
    <div class="d-flex align-items-center navbar-left" style="gap: 0;">
      <a class="navbar-brand p-0 m-0" style="margin-right: 0 !important;" href="#">
        <img src="/icons/logo.png" alt="My Fen" class="navbar-logo" style="margin-right: 0;">
      </a>
      <a href="https://t.me/ZhongKai_KL" class="dev-label m-0 p-0" style="text-decoration: none; margin-left: 5px; color: #4e73df;">Dev-中凯</a>
    </div>
    <div class="ms-auto">
      <span class="badge bg-primary me-2" style="font-size: 14px; padding: 6px 10px;">User ID: <%= userId %></span>
      <button id="installButton" class="btn btn-outline-primary btn-sm me-2" style="display: none;">
        <i class="fas fa-download"></i>
      </button>
      <a href="/auth/logout" class="btn btn-outline-danger btn-sm">
        <i class="fas fa-sign-out-alt"></i>
      </a>
    </div>
  </div>
</nav>

<!-- Offline notification -->
<div id="offlineAlert" class="offline-alert" style="display: none;">
  <div class="container">
    <i class="fas fa-wifi-slash me-2"></i> You're offline. Some features may be limited.
  </div>
</div>

<div class="chat-container">
  <!-- Chat area -->
  <div class="chat-area" id="chatArea">
    <% if (typeof error !== 'undefined') { %>
      <div class="alert alert-danger" role="alert">
        <%= error %>
      </div>
    <% } %>
    
    <% if (groupedFiles && groupedFiles.length > 0) { %>
      <% groupedFiles.forEach(group => { %>
        <div class="message-container">
          <div class="message">
            <div class="message-header">
              <strong><%= userId %></strong>
              <small class="text-muted"><%= new Date(group.date).toLocaleString() %></small>
              <div class="message-actions-header">
                <!-- Delete bubble button -->
                <form action="/files/delete-group/<%= group.groupId %>" method="POST" class="d-inline delete-message-form">
                  <button type="submit" class="btn-delete-message" onclick="return confirm('Delete this entire message?')">
                    <i class="fas fa-trash-alt"></i>
                  </button>
                </form>
              </div>
            </div>
            <div class="message-content">
              <!-- If there's a text message, show it first -->
              <% if (group.messages && group.messages.length > 0) { %>
                <% group.messages.forEach(message => { %>
                  <div class="text-message">
                    <div class="message-text-content"><%= message.text %></div>
                    <div class="message-text-actions">
                      <button class="btn-copy-message" onclick="copyMessageText(this)">
                        <i class="fas fa-copy"></i>
                      </button>
                    </div>
                  </div>
                <% }); %>
              <% } %>
              
              <!-- If group contains multiple images, show them in a grid -->
              <% if (group.files.length > 1 && group.files.every(file => file.mimetype.startsWith('image/'))) { %>
                <div class="image-grid <%= group.files.length > 4 ? 'grid-many' : group.files.length > 2 ? 'grid-' + group.files.length : '' %>">
                  <% group.files.forEach((file, index) => { %>
                    <div class="image-grid-item">
                      <img src="/files/view/<%= file._id %>" alt="<%= file.originalName %>" 
                          class="img-thumbnail chat-img" 
                          data-filename="<%= file.originalName %>"
                          data-fileid="<%= file._id %>"
                          onclick="openImagePreview(event, this)">
                    </div>
                  <% }); %>
                </div>
                <div class="file-info mt-2">
                  <div><span><%= group.files.length %> images</span></div>
                  <div class="mt-2 d-flex">
                    <button class="btn btn-sm btn-outline-primary me-2" onclick="downloadAllFiles('<%= JSON.stringify(group.files.map(f => f._id)) %>')">
                      <i class="fas fa-download"></i>
                    </button>
                    <% if (!group.files[0].extractedPhoneNumbers || !group.files[0].extractedPhoneNumbers.length) { %>
                    <button class="btn btn-sm btn-outline-secondary extract-btn" 
                            onclick="extractPhoneNumbersInline('<%= group.files[0]._id %>', event, this)">
                      <i class="fas fa-phone"></i>
                    </button>
                    <% } %>
                    <div class="extracted-numbers ms-3 <%= group.files[0].extractedPhoneNumbers && group.files[0].extractedPhoneNumbers.length ? '' : 'd-none' %>" data-fileid="<%= group.files[0]._id %>">
                      <% if (group.files[0].extractedPhoneNumbers && group.files[0].extractedPhoneNumbers.length) { %>
                        <% group.files[0].extractedPhoneNumbers.forEach(number => { %>
                          <div class="phone-number-item">
                            <span><%= number %></span>
                            <button class="copy-number-btn" onclick="copyInlineNumber('<%= number %>', this)">
                              <i class="fas fa-copy"></i>
                            </button>
                          </div>
                        <% }); %>
                      <% } %>
                    </div>
                  </div>
                </div>
              <!-- If single image, show normally -->
              <% } else if (group.files.length === 1 && group.files[0].mimetype.startsWith('image/')) { %>
                <div class="image-preview">
                  <img src="/files/view/<%= group.files[0]._id %>" alt="<%= group.files[0].originalName %>" 
                      class="img-thumbnail chat-img" 
                      data-filename="<%= group.files[0].originalName %>"
                      data-fileid="<%= group.files[0]._id %>"
                      onclick="openImagePreview(event, this)">
                  <div class="file-info mt-2">
                    <div>
                      <span><%= group.files[0].originalName %></span>
                      <small><%= (group.files[0].size / 1024).toFixed(2) %> KB</small>
                    </div>
                    <div class="mt-2 d-flex">
                      <a href="/files/download/<%= group.files[0]._id %>" class="btn btn-sm btn-outline-primary me-2">
                        <i class="fas fa-download"></i>
                      </a>
                      <% if (!group.files[0].extractedPhoneNumbers || !group.files[0].extractedPhoneNumbers.length) { %>
                      <button class="btn btn-sm btn-outline-secondary extract-btn" 
                              onclick="extractPhoneNumbersInline('<%= group.files[0]._id %>', event, this)">
                        <i class="fas fa-phone"></i>
                      </button>
                      <% } %>
                      <div class="extracted-numbers ms-3 <%= group.files[0].extractedPhoneNumbers && group.files[0].extractedPhoneNumbers.length ? '' : 'd-none' %>" data-fileid="<%= group.files[0]._id %>">
                        <% if (group.files[0].extractedPhoneNumbers && group.files[0].extractedPhoneNumbers.length) { %>
                          <% group.files[0].extractedPhoneNumbers.forEach(number => { %>
                            <div class="phone-number-item">
                              <span><%= number %></span>
                              <button class="copy-number-btn" onclick="copyInlineNumber('<%= number %>', this)">
                                <i class="fas fa-copy"></i>
                              </button>
                            </div>
                          <% }); %>
                        <% } %>
                      </div>
                    </div>
                  </div>
                </div>
              <% } %>
              
              <!-- Group-level actions for image groups -->
              <% if (group.files.length > 1 && group.files.every(file => file.mimetype.startsWith('image/'))) { %>
                <!-- Removed duplicate buttons here -->
              <% } %>
            </div>
          </div>
        </div>
      <% }); %>
    <% } else { %>
      <div class="empty-state">
        <i class="fas fa-comment-alt fa-4x text-muted mb-3"></i>
        <h5 class="text-muted">No messages yet</h5>
        <p>Start a conversation by sending a message or image below.</p>
      </div>
    <% } %>
    
    <!-- Spacer to ensure last message isn't covered by the upload form -->
    <div style="height: 80px;"></div>
  </div>
  
  <!-- Chat input form -->
  <div class="chat-input-form">
    <form action="/files/upload-images" method="post" enctype="multipart/form-data" id="chatForm" onsubmit="return handleFormSubmit(this, event);">
      <div class="input-wrapper">
        <div class="message-input-container">
          <textarea class="form-control message-input" name="message" placeholder="Type a message..." autocomplete="off" rows="1"></textarea>
          <div class="input-actions">
            <label for="imageInput" class="btn-attach">
              <i class="fas fa-image"></i>
            </label>
            <input type="file" id="imageInput" name="images" multiple accept="image/*" style="display: none;" onchange="handleSelectedFiles(event)">
            <span id="fileCount" class="file-count"></span>
          </div>
        </div>
        <button type="submit" class="btn btn-primary send-button">
          <i class="fas fa-paper-plane"></i>
        </button>
      </div>
      
      <div class="keyboard-shortcuts-hint text-muted small mt-1">
        <span class="me-3"><i class="fas fa-keyboard me-1"></i> Press <strong>Enter</strong> to send</span>
        <span><i class="fas fa-level-down-alt fa-rotate-90 me-1"></i> Press <strong>Shift+Enter</strong> for line break</span>
      </div>
      
      <!-- Pasted images preview container -->
      <div id="imagePreviewContainer" class="image-paste-preview mt-2" style="display: none;">
        <div class="preview-header d-flex justify-content-between align-items-center mb-2">
          <span class="preview-title"><i class="fas fa-images me-2"></i><span id="previewCount">0</span> images</span>
          <button type="button" class="btn-close" onclick="clearPastedImages()"></button>
        </div>
        <div id="previewGrid" class="preview-grid"></div>
      </div>
    </form>
  </div>
</div>

<!-- Image Preview Overlay -->
<div id="imagePreviewOverlay" onclick="closeImagePreview(event)">
  <div class="image-preview-container">
    <img id="previewImage" src="" alt="Preview">
    <div class="preview-controls" id="previewControls">
      <button class="nav-btn prev-btn" onclick="navigateImage(-1, event)">❮</button>
      <button class="nav-btn copy-btn" onclick="copyCurrentImage(event)">
        <i class="fas fa-copy"></i>
      </button>
      <button class="nav-btn next-btn" onclick="navigateImage(1, event)">❯</button>
    </div>
    <span id="imageCounter" class="image-counter">1/1</span>
  </div>
</div>

<script>
  // Call this on window load
  window.onload = function() {
    // Setup textarea auto-resize first so it's ready when we focus
    setupTextareaAutoResize();
    
    scrollToBottom();
    
    // Focus on the message input box
    const messageInput = document.querySelector('.message-input');
    if (messageInput) {
      // Set a small delay to ensure everything is loaded
      setTimeout(() => {
        messageInput.focus();
      }, 300);
    }
    
    // Handle virtual keyboard on mobile devices
    if (messageInput) {
      const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
      
      if (isMobile) {
        // When the input is focused (keyboard appears)
        messageInput.addEventListener('focus', function() {
          document.body.classList.add('keyboard-open');
          // Small delay to ensure the keyboard is fully open
          setTimeout(function() {
            ensureInputVisible();
            scrollToBottom();
          }, 300);
        });
        
        // Also ensure visibility when typing
        messageInput.addEventListener('input', ensureInputVisible);
        
        // When the input loses focus (keyboard disappears)
        messageInput.addEventListener('blur', function() {
          document.body.classList.remove('keyboard-open');
        });
        
        // Detect iOS keyboard
        window.addEventListener('resize', function() {
          if (document.activeElement === messageInput) {
            // Keyboard is likely open
            document.body.classList.add('keyboard-open');
            setTimeout(scrollToBottom, 300);
          }
        });
      }
    }
    
    // Setup paste event listeners for image pasting
    setupImagePasteSupport();
  };
  
  // Function to scroll to bottom of chat
  function scrollToBottom() {
    const chatArea = document.getElementById('chatArea');
    chatArea.scrollTop = chatArea.scrollHeight;
  }
  
  // Function to ensure the input is visible when typing
  function ensureInputVisible() {
    // Scroll to the input field
    const inputField = document.querySelector('.message-input');
    if (inputField) {
      inputField.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
  }
  
  // Update file label when files are selected
  function updateFileLabel() {
    const input = document.getElementById('imageInput');
    const fileCount = document.getElementById('fileCount');
    
    if (input.files.length > 0) {
      fileCount.textContent = input.files.length + (input.files.length === 1 ? ' image' : ' images');
      fileCount.style.display = 'inline-block';
    } else {
      fileCount.style.display = 'none';
    }
  }
  
  // Copy message text to clipboard
  function copyMessageText(button) {
    const messageText = button.closest('.text-message').querySelector('.message-text-content').textContent;
    navigator.clipboard.writeText(messageText).then(() => {
      // Show a brief "Copied!" tooltip
      const originalTitle = button.getAttribute('title');
      button.setAttribute('title', 'Copied!');
      button.classList.add('copied');
      
      setTimeout(() => {
        button.setAttribute('title', originalTitle);
        button.classList.remove('copied');
      }, 1500);
    });
  }
  
  // Image preview functionality
  let currentImageIndex = 0;
  let galleryImages = [];
  
  function openImagePreview(event, img) {
    if (event) {
      event.stopPropagation();
    }
    
    const previewOverlay = document.getElementById('imagePreviewOverlay');
    const previewImage = document.getElementById('previewImage');
    const previewControls = document.getElementById('previewControls');
    const imageCounter = document.getElementById('imageCounter');
    
    // Set up image loaded handler
    previewImage.onload = function() {
      // Show the overlay
      previewOverlay.style.display = 'flex';
      document.body.style.overflow = 'hidden'; // Prevent scrolling when preview is open
      
      // Hide controls and counter after 1 second
      previewControls.classList.remove('hide');
      imageCounter.classList.remove('hide');
      setTimeout(() => {
        previewControls.classList.add('hide');
        imageCounter.classList.add('hide');
      }, 1000);
    };
    
    // Set the preview image (this will trigger the onload event)
    previewImage.src = img.src;
    
    // Calculate total images and current position
    const allImages = Array.from(document.querySelectorAll('.img-thumbnail'));
    const visibleImages = allImages.filter(img => img.offsetParent !== null);
    
    // Find the index of the current image
    let currentIndex = -1;
    for (let i = 0; i < visibleImages.length; i++) {
      if (visibleImages[i].src === img.src) {
        currentIndex = i;
        break;
      }
    }
    
    // Update counter
    updateImageCounter(currentIndex, visibleImages.length);
    
    // Remember current state for navigation
    previewOverlay.dataset.currentIndex = currentIndex;
    previewOverlay.dataset.totalImages = visibleImages.length;
  }
  
  function updateImageCounter(currentIndex, totalImages) {
    const counter = document.getElementById('imageCounter');
    counter.textContent = `${currentIndex + 1}/${totalImages}`;
  }
  
  function navigateImage(direction, event) {
    if (event) {
      event.stopPropagation();
    }
    
    const previewOverlay = document.getElementById('imagePreviewOverlay');
    const previewImage = document.getElementById('previewImage');
    const previewControls = document.getElementById('previewControls');
    const imageCounter = document.getElementById('imageCounter');
    
    // Get all image elements
    const allImages = Array.from(document.querySelectorAll('.img-thumbnail'));
    const visibleImages = allImages.filter(img => img.offsetParent !== null);
    
    // Get current index from dataset
    let currentIndex = parseInt(previewOverlay.dataset.currentIndex) || 0;
    const totalImages = parseInt(previewOverlay.dataset.totalImages) || visibleImages.length;
    
    // Calculate the new index
    let newIndex = currentIndex + direction;
    
    // Stop at boundaries instead of wrapping around
    if (newIndex < 0) {
      newIndex = 0; // Stop at first image
      return; // Don't proceed if already at first image
    } else if (newIndex >= visibleImages.length) {
      newIndex = visibleImages.length - 1; // Stop at last image
      return; // Don't proceed if already at last image
    }
    
    // Set the new image and update counter
    if (visibleImages[newIndex]) {
      // Set up image loaded handler
      previewImage.onload = function() {
        // Show controls and counter, hide after 1 second
        previewControls.classList.remove('hide');
        imageCounter.classList.remove('hide');
        
        // Clear any existing timeout
        if (window.previewTimeout) {
          clearTimeout(window.previewTimeout);
        }
        
        // Set new timeout
        window.previewTimeout = setTimeout(() => {
          previewControls.classList.add('hide');
          imageCounter.classList.add('hide');
        }, 1000);
      };
      
      // Set the new image (this will trigger the onload event)
      previewImage.src = visibleImages[newIndex].src;
      
      updateImageCounter(newIndex, totalImages);
      
      // Update current index
      previewOverlay.dataset.currentIndex = newIndex;
    }
  }
  
  // Add mouse wheel navigation with specified direction
  document.getElementById('imagePreviewOverlay').addEventListener('wheel', function(e) {
    e.preventDefault(); // Prevent page scrolling
    if (e.deltaY > 0) {
      // Scrolling down - go to next image
      navigateImage(1, e);
    } else {
      // Scrolling up - go to previous image
      navigateImage(-1, e);
    }
  });
  
  function closeImagePreview(event) {
    if (event) {
      event.stopPropagation();
    }
    
    const previewOverlay = document.getElementById('imagePreviewOverlay');
    previewOverlay.style.display = 'none';
    document.body.style.overflow = ''; // Restore scrolling
  }
  
  // Add touch swipe support for mobile
  let touchStartX = 0;
  let touchEndX = 0;
  
  function setupSwipeListeners() {
    const previewImage = document.getElementById('previewImage');
    const previewOverlay = document.getElementById('imagePreviewOverlay');
    
    // Add touch event listeners to the entire overlay for better swipe detection
    previewOverlay.addEventListener('touchstart', function(e) {
      touchStartX = e.changedTouches[0].screenX;
    }, { passive: false });
    
    previewOverlay.addEventListener('touchend', function(e) {
      touchEndX = e.changedTouches[0].screenX;
      handleSwipe(e);
    }, { passive: false });
  }
  
  // Setup swipe listeners when the DOM is loaded
  document.addEventListener('DOMContentLoaded', setupSwipeListeners);
  
  function handleSwipe(e) {
    const swipeThreshold = 50; // Minimum distance to consider as swipe
    if (touchEndX < touchStartX - swipeThreshold) {
      // Swipe left - go to next image
      navigateImage(1, e);
    } else if (touchEndX > touchStartX + swipeThreshold) {
      // Swipe right - go to previous image
      navigateImage(-1, e);
    }
  }
  
  // Add keyboard navigation
  document.addEventListener('keydown', function(e) {
    if (document.getElementById('imagePreviewOverlay').style.display === 'flex') {
      if (e.key === 'ArrowLeft') {
        navigateImage(-1, e);
      } else if (e.key === 'ArrowRight') {
        navigateImage(1, e);
      } else if (e.key === 'Escape') {
        closeImagePreview(e);
      }
      
      // Prevent default behavior for arrow keys and Escape
      if (['ArrowLeft', 'ArrowRight', 'Escape'].includes(e.key)) {
        e.preventDefault();
      }
    }
  });
  
  // Show controls and counter when mouse moves
  document.getElementById('imagePreviewOverlay').addEventListener('mousemove', function() {
    const previewControls = document.getElementById('previewControls');
    const imageCounter = document.getElementById('imageCounter');
    
    // Show both elements
    previewControls.classList.remove('hide');
    imageCounter.classList.remove('hide');
    
    // Clear any existing timeout
    if (window.previewTimeout) {
      clearTimeout(window.previewTimeout);
    }
    
    // Set a new timeout
    window.previewTimeout = setTimeout(() => {
      previewControls.classList.add('hide');
      imageCounter.classList.add('hide');
    }, 1000);
  });
  
  // Helper function for file icons
  function getFileIcon(mimetype) {
    if (mimetype.startsWith('image/')) return 'fa-file-image text-primary';
    if (mimetype === 'application/pdf') return 'fa-file-pdf text-danger';
    if (mimetype.includes('document') || mimetype.includes('word')) return 'fa-file-word text-primary';
    if (mimetype.includes('spreadsheet') || mimetype.includes('excel')) return 'fa-file-excel text-success';
    if (mimetype.includes('audio')) return 'fa-file-audio text-warning';
    if (mimetype.includes('video')) return 'fa-file-video text-danger';
    if (mimetype.includes('zip') || mimetype.includes('compressed')) return 'fa-file-archive text-warning';
    if (mimetype.includes('text/')) return 'fa-file-alt text-info';
    return 'fa-file text-secondary';
  }
  
  // Download all files in a group
  function downloadAllFiles(fileIds) {
    try {
      const ids = JSON.parse(fileIds);
      
      // Create an invisible iframe to handle downloads
      const downloadFrame = document.createElement('iframe');
      downloadFrame.style.display = 'none';
      document.body.appendChild(downloadFrame);
      
      // Function to download sequentially
      function downloadNext(index) {
        if (index >= ids.length) {
          // All downloads initiated, clean up
          setTimeout(() => {
            document.body.removeChild(downloadFrame);
          }, 5000); // Allow time for downloads to start
          return;
        }
        
        // Set the iframe src to the download URL
        const downloadUrl = '/files/download/' + ids[index];
        
        // For the first download, navigate directly
        if (index === 0) {
          downloadFrame.src = downloadUrl;
        } else {
          // For subsequent downloads, use a small delay
          setTimeout(() => {
            downloadFrame.src = downloadUrl;
          }, 500 * index); // Space out downloads by 500ms each
        }
        
        // Process next download
        downloadNext(index + 1);
      }
      
      // Start downloading
      downloadNext(0);
    } catch (e) {
      console.error('Error downloading files:', e);
    }
  }

  // Document ready function
  document.addEventListener('DOMContentLoaded', function() {
    // Set up image preview
    document.querySelectorAll('.chat-img, .image-grid-item img').forEach(img => {
      img.addEventListener('click', function(e) {
        e.preventDefault();
        openImagePreview(e, this);
      });
    });
    
    // Enable right-click and context menu on preview image
    document.getElementById('previewImage').addEventListener('contextmenu', function(e) {
      // Allow default context menu to enable "Copy Image"
      e.stopPropagation();
      return true;
    });
    
    // Prevent buttons from closing the preview when clicked
    document.querySelectorAll('.nav-btn').forEach(button => {
      button.addEventListener('click', function(e) {
        e.stopPropagation();
      });
    });
    
    // Handle PWA installation
    let deferredPrompt;
    const installButton = document.getElementById('installButton');
    
    window.addEventListener('beforeinstallprompt', (e) => {
      // Prevent Chrome 67 and earlier from automatically showing the prompt
      e.preventDefault();
      // Stash the event so it can be triggered later
      deferredPrompt = e;
      // Show the install button
      installButton.style.display = 'inline-block';
    });
    
    installButton.addEventListener('click', async () => {
      if (!deferredPrompt) {
        return;
      }
      // Show the installation prompt
      deferredPrompt.prompt();
      // Wait for the user to respond to the prompt
      const { outcome } = await deferredPrompt.userChoice;
      // Hide the install button regardless of outcome
      installButton.style.display = 'none';
      // We no longer need the prompt
      deferredPrompt = null;
    });
    
    // Handle iOS install prompt
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    const isInStandaloneMode = window.matchMedia('(display-mode: standalone)').matches;
    
    if (isIOS && !isInStandaloneMode && !localStorage.getItem('pwaInstallPromptShown')) {
      // Create a custom installation prompt for iOS
      const iosPrompt = document.createElement('div');
      iosPrompt.className = 'pwa-install-prompt';
      iosPrompt.innerHTML = `
        <div class="pwa-install-prompt-icon">
          <i class="fas fa-mobile-alt"></i>
        </div>
        <div class="pwa-install-prompt-text">
          <div class="pwa-install-prompt-title">Add to Home Screen</div>
          <div>Install this app on your device for quick access.</div>
          <div class="pwa-install-prompt-actions">
            <button class="btn btn-sm btn-outline-secondary" id="iosDismissBtn">Not Now</button>
            <button class="btn btn-sm btn-primary" id="iosInstallBtn">How to Install</button>
          </div>
        </div>
      `;
      document.body.appendChild(iosPrompt);
      
      // Handle iOS prompt buttons
      document.getElementById('iosDismissBtn').addEventListener('click', () => {
        iosPrompt.remove();
        localStorage.setItem('pwaInstallPromptShown', 'true');
      });
      
      document.getElementById('iosInstallBtn').addEventListener('click', () => {
        alert('To install: tap the Share button in Safari and then "Add to Home Screen"');
        localStorage.setItem('pwaInstallPromptShown', 'true');
      });
    }
    
    // Offline detection
    const offlineAlert = document.getElementById('offlineAlert');
    
    function updateOnlineStatus() {
      if (navigator.onLine) {
        offlineAlert.style.display = 'none';
      } else {
        offlineAlert.style.display = 'block';
      }
    }
    
    window.addEventListener('online', updateOnlineStatus);
    window.addEventListener('offline', updateOnlineStatus);
    updateOnlineStatus(); // Initial check
    
    // Add form submission handlers
    document.querySelectorAll('form').forEach(form => {
      form.addEventListener('submit', function(e) {
        // Don't submit for delete confirmations that are cancelled
        if (this.action.includes('delete') && !window.lastDeleteConfirmed) {
          e.preventDefault();
          return false;
        }
        
        // Check for upload forms
        if (this.action.includes('upload')) {
          // Check if files are actually selected for upload forms
          const fileInput = this.querySelector('input[type="file"]');
          if (fileInput && fileInput.files.length === 0 && !this.querySelector('input[name="message"]').value) {
            e.preventDefault();
            return false;
          }
        }
        
        return true;
      });
    });
    
    // Handle delete confirmation
    document.querySelectorAll('button[onclick*="confirm"]').forEach(button => {
      const originalOnClick = button.getAttribute('onclick');
      
      button.setAttribute('onclick', '');
      button.addEventListener('click', function(e) {
        e.preventDefault();
        window.lastDeleteConfirmed = confirm('Are you sure you want to delete this?');
        if (window.lastDeleteConfirmed) {
          this.closest('form').submit();
        }
      });
    });
  });

  // Show copy animation with shorter duration
  function copyCurrentImage(event) {
    if (event) {
      event.stopPropagation();
    }
    
    const previewImage = document.getElementById('previewImage');
    
    // Show copy animation regardless of success
    const copyBtn = document.querySelector('.copy-btn');
    const originalHTML = copyBtn.innerHTML;
    
    // Try using modern Clipboard API first
    if (navigator.clipboard && navigator.clipboard.write) {
      // Create a canvas element
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      // Set canvas dimensions to match the image
      canvas.width = previewImage.naturalWidth;
      canvas.height = previewImage.naturalHeight;
      
      // Draw the image on the canvas
      ctx.drawImage(previewImage, 0, 0);
      
      // Convert canvas to blob
      canvas.toBlob(function(blob) {
        // Create a new ClipboardItem
        const data = new ClipboardItem({ 'image/png': blob });
        
        // Write to clipboard
        navigator.clipboard.write([data])
          .then(() => {
            // Show success feedback with shorter animation
            copyBtn.innerHTML = '<i class="fas fa-check"></i>';
            
            // Reset after 500ms (shorter duration)
            setTimeout(() => {
              copyBtn.innerHTML = originalHTML;
            }, 500);
          })
          .catch(err => {
            console.error('Error copying image to clipboard:', err);
            fallbackCopyMethod();
          });
      });
    } else {
      fallbackCopyMethod();
    }
    
    // Fallback method using select and copy commands
    function fallbackCopyMethod() {
      try {
        // Create a temporary link element
        const tempLink = document.createElement('a');
        tempLink.href = previewImage.src;
        tempLink.download = 'image.jpg';
        document.body.appendChild(tempLink);
        tempLink.click();
        document.body.removeChild(tempLink);
        
        // Show download message with shorter animation
        copyBtn.innerHTML = '<i class="fas fa-download"></i>';
        
        // Reset after 500ms (shorter duration)
        setTimeout(() => {
          copyBtn.innerHTML = originalHTML;
        }, 500);
      } catch (err) {
        console.error('Error downloading image:', err);
        alert('Could not copy image. Please try right-clicking and selecting "Copy Image" or "Save Image As".');
        copyBtn.innerHTML = originalHTML;
      }
    }
  }

  // Function to format phone number for display
  function formatPhoneNumber(phoneNumber) {
    // Return raw E.164 format: 1XXXXXXXXXX without any formatting
    // Ensure it has the country code
    if (phoneNumber.length === 10) {
      return `1${phoneNumber}`;
    } else if (phoneNumber.length === 11 && phoneNumber.startsWith('1')) {
      return phoneNumber;
    }
    
    // Fallback to raw format if we can't parse it
    return phoneNumber;
  }

  // Function to extract phone numbers and display them inline
  function extractPhoneNumbersInline(fileId, event, buttonElement) {
    if (event) {
      event.stopPropagation(); // Prevent image preview from opening
    }
    
    // Find the extracted numbers container
    const extractedContainer = buttonElement.parentElement.querySelector('.extracted-numbers');
    
    // If numbers are already showing, do nothing
    if (!extractedContainer.classList.contains('d-none')) {
      return;
    }
    
    // Show loading state
    extractedContainer.classList.remove('d-none');
    extractedContainer.innerHTML = `
      <div class="phone-number-loading">
        <span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>
        <span>Extracting...</span>
      </div>
    `;
    
    // Show loading state in the button
    const originalHTML = buttonElement.innerHTML;
    buttonElement.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>';
    buttonElement.disabled = true;
    
    // Get the image URL
    const imgElement = document.querySelector(`img[data-fileid="${fileId}"]`);
    if (!imgElement) {
      extractedContainer.innerHTML = `<div class="text-danger">Error: Image not found!</div>`;
      buttonElement.innerHTML = originalHTML;
      buttonElement.disabled = false;
      return;
    }
    
    const imageUrl = imgElement.src;
    
    // Use Tesseract.js to perform OCR
    Tesseract.recognize(
      imageUrl,
      'eng',
      { 
        logger: m => console.log(m),
        tessedit_char_whitelist: '0123456789()-+. '
      }
    )
    .then(({ data: { text } }) => {
      // Extract phone numbers with our patterns
      const phoneNumbers = extractPhoneNumbersFromText(text);
      
      // Save the extracted numbers to the server
      saveExtractedPhoneNumbers(fileId, phoneNumbers)
        .then(() => {
          // Show results inline
          displayPhoneNumbersInline(phoneNumbers, extractedContainer);
          
          // Reset button
          buttonElement.innerHTML = originalHTML;
          buttonElement.disabled = false;
        })
        .catch(error => {
          console.error('Error saving phone numbers:', error);
          // Still show the numbers even if save fails
          displayPhoneNumbersInline(phoneNumbers, extractedContainer);
          buttonElement.innerHTML = originalHTML;
          buttonElement.disabled = false;
        });
    })
    .catch(error => {
      console.error('OCR error:', error);
      extractedContainer.innerHTML = `<div class="text-danger">Error: ${error.message}</div>`;
      buttonElement.innerHTML = originalHTML;
      buttonElement.disabled = false;
    });
  }
  
  // Function to save extracted phone numbers to the server
  async function saveExtractedPhoneNumbers(fileId, phoneNumbers) {
    try {
      const response = await fetch(`/files/save-phone-numbers/${fileId}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ phoneNumbers })
      });
      
      const data = await response.json();
      
      if (!data.success) {
        throw new Error(data.error || 'Failed to save phone numbers');
      }
      
      return data;
    } catch (error) {
      console.error('Error saving phone numbers:', error);
      throw error;
    }
  }
  
  // Function to extract phone numbers from text
  function extractPhoneNumbersFromText(text) {
    console.log("Extracted text:", text);  // Debug log
    
    // Multiple patterns to catch different formats
    const patterns = [
      // Format with parentheses: (555) 123-4567
      /(?:\+?1[ -]?)?(?:\(([2-9][0-9]{2})\)[ -]?)([2-9][0-9]{2})[ -]?([0-9]{4})/g,
      
      // Format with dashes/spaces: 555-123-4567
      /(?:\+?1[ -]?)?(?:([2-9][0-9]{2})[ -])([2-9][0-9]{2})[ -]([0-9]{4})/g,
      
      // Format with dots: 555.123.4567
      /(?:\+?1[ \.]?)?(?:([2-9][0-9]{2})[ \.])([2-9][0-9]{2})[ \.]([0-9]{4})/g,
      
      // Straight format with no separators: 5551234567
      /(?:\+?1)?([2-9][0-9]{2})([2-9][0-9]{2})([0-9]{4})/g,
      
      // Format for 11-digit with country code: 15551234567
      /(?:^|\D)(1)([2-9][0-9]{2})([0-9]{3})([0-9]{4})(?:$|\D)/g
    ];
    
    const numbers = [];
    
    // Try each pattern
    patterns.forEach(pattern => {
      let match;
      const textCopy = text.toString();  // Create a copy for each pattern
      while ((match = pattern.exec(textCopy)) !== null) {
        let areaCode, prefix, lineNumber, countryCode;
        
        if (match.length === 5) {
          // Format for 11-digit with country code
          countryCode = match[1];
          areaCode = match[2];
          prefix = match[3];
          lineNumber = match[4];
        } else {
          // Other formats
          areaCode = match[1] || '';
          prefix = match[2] || '';
          lineNumber = match[3] || '';
        }
        
        if (areaCode && prefix && lineNumber) {
          const formattedNumber = `1${areaCode}${prefix}${lineNumber}`;
          if (formattedNumber.length === 11) {
            numbers.push(formattedNumber);
          }
        }
      }
    });
    
    // Special case for raw 10-digit or 11-digit numbers
    const rawNumberPattern = /\b(1)?([2-9][0-9]{2})([0-9]{3})([0-9]{4})\b/g;
    let rawMatch;
    const textCopy = text.toString();
    while ((rawMatch = rawNumberPattern.exec(textCopy)) !== null) {
      const countryCode = rawMatch[1] || '1';
      const areaCode = rawMatch[2];
      const prefix = rawMatch[3];
      const lineNumber = rawMatch[4];
      
      numbers.push(`${countryCode}${areaCode}${prefix}${lineNumber}`);
    }
    
    // Ensure all numbers are in E.164 format (just digits, no spaces or special chars)
    const formattedNumbers = numbers.map(number => {
      // Remove any non-digit characters
      const digitsOnly = number.replace(/\D/g, '');
      
      // Ensure it has country code
      if (digitsOnly.length === 10) {
        return `1${digitsOnly}`;
      } else if (digitsOnly.length === 11 && digitsOnly.startsWith('1')) {
        return digitsOnly;
      }
      
      return number; // Return original if we can't format it
    });
    
    // Return unique numbers in E.164 format
    return [...new Set(formattedNumbers)];
  }
  
  // Display phone numbers inline in the container
  function displayPhoneNumbersInline(numbers, container) {
    container.innerHTML = '';
    
    if (numbers && numbers.length > 0) {
      // Create a container for each number
      numbers.forEach(number => {
        const phoneItem = document.createElement('div');
        phoneItem.className = 'phone-number-item';
        
        const formattedNumber = formatPhoneNumber(number);
        phoneItem.innerHTML = `
          <span>${formattedNumber}</span>
          <button class="copy-number-btn" onclick="copyInlineNumber('${number}', this)">
            <i class="fas fa-copy"></i>
          </button>
        `;
        
        container.appendChild(phoneItem);
      });
    } else {
      container.innerHTML = `<div class="text-muted">No phone numbers found</div>`;
    }
  }
  
  // Function to copy an inline phone number
  function copyInlineNumber(number, button) {
    navigator.clipboard.writeText(number).then(() => {
      // Success feedback
      const originalHTML = button.innerHTML;
      button.innerHTML = '<i class="fas fa-check"></i>';
      
      // Reset after 1.5 seconds
      setTimeout(() => {
        button.innerHTML = originalHTML;
      }, 1500);
    });
  }

  // Image paste related functions
  let pastedImages = [];
  const MAX_PASTED_IMAGES = 9;

  function setupImagePasteSupport() {
    // Listen for paste events on the document
    document.addEventListener('paste', handlePaste);
  }

  function handlePaste(e) {
    // Check if we have clipboard data
    if (!e.clipboardData || !e.clipboardData.items) {
      return;
    }
    
    const items = e.clipboardData.items;
    let hasImages = false;
    
    // First check if there are any images
    for (let i = 0; i < items.length; i++) {
      if (items[i].type.indexOf('image') !== -1) {
        hasImages = true;
        break;
      }
    }
    
    // If no images found, allow default paste behavior for text
    if (!hasImages) {
      return;
    }
    
    // We found images, handle the paste ourselves
    e.preventDefault();
    
    // Collect all image files from this paste
    let newImages = [];
    for (let i = 0; i < items.length; i++) {
      if (items[i].type.indexOf('image') !== -1) {
        const blob = items[i].getAsFile();
        if (blob) {
          newImages.push(blob);
        }
      }
    }
    
    // If we found new images, add them to our collection
    if (newImages.length > 0) {
      console.log(`Adding ${newImages.length} new pasted images`);
      
      // Check if adding these would exceed the limit
      if (pastedImages.length + newImages.length > MAX_PASTED_IMAGES) {
        // Only add up to the limit
        const remaining = MAX_PASTED_IMAGES - pastedImages.length;
        if (remaining <= 0) {
          alert(`Maximum of ${MAX_PASTED_IMAGES} images reached. Cannot add more images.`);
          return;
        }
        
        alert(`Only adding ${remaining} more images to stay within the ${MAX_PASTED_IMAGES} image limit.`);
        newImages = newImages.slice(0, remaining);
      }
      
      // Add new images to existing collection
      pastedImages = pastedImages.concat(newImages);
      
      // Display updated preview
      displayImagePreviews(pastedImages);
      
      // Setup form to handle these images on submit
      setupPasteSubmitHandler();
    }
  }
  
  function displayImagePreviews(images) {
    // Get UI elements
    const container = document.getElementById('imagePreviewContainer');
    const previewGrid = document.getElementById('previewGrid');
    const previewCount = document.getElementById('previewCount');
    
    // Clear grid
    previewGrid.innerHTML = '';
    
    // Update count
    previewCount.textContent = images.length;
    
    // Show container
    container.style.display = 'block';
    
    // Update file count indicator
    const fileCount = document.getElementById('fileCount');
    fileCount.textContent = images.length + (images.length === 1 ? ' image' : ' images');
    fileCount.style.display = 'inline-block';
    
    // Make sure the close button clears all images
    const closeBtn = container.querySelector('.btn-close');
    if (closeBtn) {
      closeBtn.onclick = clearPastedImages;
    }
    
    // Create a preview for each image
    images.forEach((blob, index) => {
      const reader = new FileReader();
      reader.onload = function(event) {
        const previewItem = document.createElement('div');
        previewItem.className = 'preview-item';
        previewItem.innerHTML = `
          <img src="${event.target.result}" alt="Pasted image ${index + 1}">
          <button type="button" class="remove-btn" data-index="${index}">×</button>
        `;
        previewGrid.appendChild(previewItem);
        
        // Add event listener to remove button
        const removeBtn = previewItem.querySelector('.remove-btn');
        removeBtn.addEventListener('click', function() {
          // Remove this specific image
          removeImageAtIndex(index);
        });
      };
      reader.readAsDataURL(blob);
    });
    
    // Ensure the message area scrolls down to show the preview
    setTimeout(scrollToBottom, 100);
  }
  
  function removeImageAtIndex(index) {
    // Remove the image at the specified index
    if (index >= 0 && index < pastedImages.length) {
      // Remove the image from the array
      pastedImages.splice(index, 1);
      
      if (pastedImages.length === 0) {
        // If no images left, clear everything
        clearPastedImages();
      } else {
        // Otherwise, update the preview
        displayImagePreviews(pastedImages);
      }
    }
  }
  
  function setupPasteSubmitHandler() {
    // We no longer need this function as the form submit handler in window.onload now handles pasted images
    // This is kept as an empty function in case it's called elsewhere
    console.log("Using main form handler for pasted images");
  }

  function clearPastedImages() {
    // Clear global array
    pastedImages = [];
    
    // Reset file input
    const input = document.getElementById('imageInput');
    input.value = '';
    
    // Hide preview
    const container = document.getElementById('imagePreviewContainer');
    container.style.display = 'none';
    
    // Reset file count
    const fileCount = document.getElementById('fileCount');
    fileCount.style.display = 'none';
    
    // Reset form submit handler
    const form = document.getElementById('chatForm');
    if (form._originalSubmit) {
      form.onsubmit = form._originalSubmit;
    }
  }

  function updateFileCount() {
    const input = document.getElementById('imageInput');
    const fileCount = document.getElementById('fileCount');
    
    if (input.files && input.files.length > 0) {
      fileCount.textContent = input.files.length + (input.files.length === 1 ? ' image' : ' images');
      fileCount.style.display = 'inline-block';
    } else {
      fileCount.style.display = 'none';
    }
  }

  function handleSelectedFiles(event) {
    const files = event.target.files;
    
    // Check for file limit
    if (files.length > MAX_PASTED_IMAGES) {
      alert(`Maximum of ${MAX_PASTED_IMAGES} images allowed.`);
      clearPastedImages();
      return;
    }
    
    // If no files, just clear everything
    if (files.length === 0) {
      clearPastedImages();
      return;
    }
    
    // Clear any pasted images since we're using selected files
    pastedImages = [];
    
    // Create array from FileList
    const fileArray = Array.from(files);
    
    // Display previews
    displayImagePreviews(fileArray);
  }

  // Auto-resize the textarea based on content
  function setupTextareaAutoResize() {
    const textarea = document.querySelector('.message-input');
    if (textarea) {
      // Set initial height
      textarea.style.height = 'auto';
      
      // Function to update height
      const updateHeight = () => {
        textarea.style.height = 'auto';
        textarea.style.height = (textarea.scrollHeight) + 'px';
      };
      
      // Add event listeners
      textarea.addEventListener('input', updateHeight);
      textarea.addEventListener('focus', updateHeight);
      
      // Handle Enter key for sending and Shift+Enter for new line
      textarea.addEventListener('keydown', function(e) {
        // Check if Enter key was pressed
        if (e.key === 'Enter') {
          // If Shift is not held, send the message
          if (!e.shiftKey) {
            e.preventDefault(); // Prevent default (which would add a line break)
            console.log("Enter pressed - attempting to send message");
            
            // Get the form and submit it
            const form = document.getElementById('chatForm');
            if (form) {
              // Click the submit button
              const submitBtn = form.querySelector('button[type="submit"]');
              if (submitBtn) {
                submitBtn.click();
              } else {
                form.submit();
              }
            }
          }
          // If Shift+Enter, do nothing and let the default line break happen
        }
      });
      
      // Initial height adjustment
      setTimeout(updateHeight, 100);
    }
  }

  // Form submission handler
  function handleFormSubmit(form, e) {
    console.log("Form submission function called");
    
    // Validate that we have either a message or images
    const messageInput = form.querySelector('.message-input');
    const fileInput = document.getElementById('imageInput');
    
    if ((!messageInput || !messageInput.value.trim()) && 
        (!fileInput || fileInput.files.length === 0) && 
        (!pastedImages || pastedImages.length === 0)) {
      // No message and no images, prevent submission
      console.log("No content to send - preventing submission");
      return false;
    }
    
    // Show loading indicator
    const btn = form.querySelector('button[type="submit"]');
    btn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>';
    btn.disabled = true;
    
    // If we have pasted images but no files in the input
    if (pastedImages.length > 0 && (!fileInput.files || fileInput.files.length === 0)) {
      console.log("Submitting form with pasted images");
      
      // Create FormData from the form
      const formData = new FormData(form);
      
      // Add each pasted image
      pastedImages.forEach((blob, index) => {
        const fileName = `pasted-image-${Date.now()}-${index}.png`;
        formData.append('images', new File([blob], fileName, { type: blob.type }));
      });
      
      // Submit with fetch
      fetch(form.action, {
        method: 'POST',
        body: formData
      })
      .then(response => {
        if (response.redirected) {
          window.location.href = response.url;
        } else {
          return response.text().then(html => {
            document.open();
            document.write(html);
            document.close();
          });
        }
      })
      .catch(error => {
        console.error('Error submitting form:', error);
        btn.innerHTML = '<i class="fas fa-paper-plane"></i>';
        btn.disabled = false;
        alert('Error sending message. Please try again.');
      });
      
      return false;
    }
    
    console.log("Proceeding with normal form submission");
    return true;
  }
</script> 