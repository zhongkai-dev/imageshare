<!-- Navbar -->
<nav class="navbar navbar-expand-lg navbar-light bg-white shadow-sm fixed-top">
  <div class="container">
    <a class="navbar-brand" href="#">Image Share</a>
    <div class="ms-auto">
      <span class="badge bg-primary me-2">User ID: <%= userId %></span>
      <button id="installButton" class="btn btn-outline-primary btn-sm me-2" style="display: none;">
        <i class="fas fa-download me-1"></i> Install App
      </button>
      <a href="/auth/logout" class="btn btn-outline-danger btn-sm">Logout</a>
    </div>
  </div>
</nav>

<!-- Offline notification -->
<div id="offlineAlert" class="offline-alert" style="display: none;">
  <div class="container">
    <i class="fas fa-wifi-slash me-2"></i> You're offline. Some features may be limited.
  </div>
</div>

<div class="chat-container">
  <!-- Chat area -->
  <div class="chat-area" id="chatArea">
    <% if (typeof error !== 'undefined') { %>
      <div class="alert alert-danger" role="alert">
        <%= error %>
      </div>
    <% } %>
    
    <% if (groupedFiles && groupedFiles.length > 0) { %>
      <% groupedFiles.forEach(group => { %>
        <div class="message-container">
          <div class="message">
            <div class="message-header">
              <strong><%= userId %></strong>
              <small class="text-muted"><%= new Date(group.date).toLocaleString() %></small>
              <div class="message-actions-header">
                <!-- Delete bubble button -->
                <form action="/files/delete-group/<%= group.groupId %>" method="POST" class="d-inline delete-message-form">
                  <button type="submit" class="btn-delete-message" title="Delete message" onclick="return confirm('Delete this entire message?')">
                    <i class="fas fa-trash-alt"></i>
                  </button>
                </form>
              </div>
            </div>
            <div class="message-content">
              <!-- If there's a text message, show it first -->
              <% if (group.messages && group.messages.length > 0) { %>
                <% group.messages.forEach(message => { %>
                  <div class="text-message">
                    <div class="message-text-content"><%= message.text %></div>
                    <div class="message-text-actions">
                      <button class="btn-copy-message" onclick="copyMessageText(this)" title="Copy message">
                        <i class="fas fa-copy"></i>
                      </button>
                    </div>
                  </div>
                <% }); %>
              <% } %>
              
              <!-- If group contains multiple images, show them in a grid -->
              <% if (group.files.length > 1 && group.files.every(file => file.mimetype.startsWith('image/'))) { %>
                <div class="image-grid <%= group.files.length > 4 ? 'grid-many' : group.files.length > 2 ? 'grid-' + group.files.length : '' %>">
                  <% group.files.forEach(file => { %>
                    <div class="image-grid-item">
                      <img src="/files/view/<%= file._id %>" alt="<%= file.originalName %>" 
                          class="img-thumbnail chat-img" 
                          data-filename="<%= file.originalName %>"
                          onclick="openImagePreview(event, this)">
                    </div>
                  <% }); %>
                </div>
                <div class="file-info mt-2">
                  <span><%= group.files.length %> images</span>
                </div>
              <!-- If single image, show normally -->
              <% } else if (group.files.length === 1 && group.files[0].mimetype.startsWith('image/')) { %>
                <div class="image-preview">
                  <img src="/files/view/<%= group.files[0]._id %>" alt="<%= group.files[0].originalName %>" 
                      class="img-thumbnail chat-img" 
                      data-filename="<%= group.files[0].originalName %>"
                      onclick="openImagePreview(event, this)">
                  <div class="file-info">
                    <span><%= group.files[0].originalName %></span>
                    <small><%= (group.files[0].size / 1024).toFixed(2) %> KB</small>
                  </div>
                </div>
              <% } %>
              
              <!-- Group-level actions for image groups -->
              <% if (group.files.length > 1 && group.files.every(file => file.mimetype.startsWith('image/'))) { %>
                <div class="message-actions mt-2">
                  <div class="btn-group">
                    <button class="btn btn-sm btn-outline-primary" onclick="downloadAllFiles('<%= JSON.stringify(group.files.map(f => f._id)) %>')">
                      <i class="fas fa-download"></i> Download All
                    </button>
                  </div>
                </div>
              <% } %>
            </div>
          </div>
        </div>
      <% }); %>
    <% } else { %>
      <div class="empty-state">
        <i class="fas fa-comment-alt fa-4x text-muted mb-3"></i>
        <h5 class="text-muted">No messages yet</h5>
        <p>Start a conversation by sending a message or image below.</p>
      </div>
    <% } %>
    
    <!-- Spacer to ensure last message isn't covered by the upload form -->
    <div style="height: 80px;"></div>
  </div>
  
  <!-- Chat input form -->
  <div class="chat-input-form">
    <form action="/files/upload-images" method="post" enctype="multipart/form-data" id="chatForm">
      <div class="input-wrapper">
        <div class="message-input-container">
          <input type="text" class="form-control message-input" name="message" placeholder="Type a message..." autocomplete="off">
          <div class="input-actions">
            <label for="imageInput" class="btn-attach" title="Attach images">
              <i class="fas fa-image"></i>
            </label>
            <input type="file" id="imageInput" name="images" multiple accept="image/*" style="display: none;" onchange="updateFileLabel()">
            <span id="fileCount" class="file-count"></span>
          </div>
        </div>
        <button type="submit" class="btn btn-primary send-button">
          <i class="fas fa-paper-plane"></i>
        </button>
      </div>
    </form>
  </div>
</div>

<!-- Image Preview Overlay -->
<div id="imagePreviewOverlay" onclick="closeImagePreview(event)">
  <div class="image-preview-container" onclick="event.stopPropagation()">
    <img id="previewImage" src="" alt="Preview">
    <div class="preview-controls" id="previewControls">
      <button class="nav-btn prev-btn" onclick="navigateImage(-1, event)">❮</button>
      <button class="nav-btn next-btn" onclick="navigateImage(1, event)">❯</button>
    </div>
    <div class="preview-info">
      <span id="imageCounter">1/1</span>
      <button class="close-btn" onclick="closeImagePreview(event)">&times;</button>
    </div>
  </div>
</div>

<script>
  // Scroll to bottom of chat on load
  window.onload = function() {
    scrollToBottom();
    
    // Add submit handlers to show loading indicators
    document.getElementById('chatForm').addEventListener('submit', function() {
      const btn = this.querySelector('button[type="submit"]');
      btn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>';
      btn.disabled = true;
    });
    
    // Handle virtual keyboard on mobile devices
    const messageInput = document.querySelector('.message-input');
    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    
    if (isMobile) {
      // When the input is focused (keyboard appears)
      messageInput.addEventListener('focus', function() {
        document.body.classList.add('keyboard-open');
        // Small delay to ensure the keyboard is fully open
        setTimeout(function() {
          ensureInputVisible();
          scrollToBottom();
        }, 300);
      });
      
      // Also ensure visibility when typing
      messageInput.addEventListener('input', ensureInputVisible);
      
      // When the input loses focus (keyboard disappears)
      messageInput.addEventListener('blur', function() {
        document.body.classList.remove('keyboard-open');
      });
      
      // Detect iOS keyboard
      window.addEventListener('resize', function() {
        if (document.activeElement === messageInput) {
          // Keyboard is likely open
          document.body.classList.add('keyboard-open');
          setTimeout(scrollToBottom, 300);
        }
      });
    }
  };
  
  // Function to scroll to bottom of chat
  function scrollToBottom() {
    const chatArea = document.getElementById('chatArea');
    chatArea.scrollTop = chatArea.scrollHeight;
  }
  
  // Function to ensure the input is visible when typing
  function ensureInputVisible() {
    // Scroll to the input field
    const inputField = document.querySelector('.message-input');
    if (inputField) {
      inputField.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
  }
  
  // Update file label when files are selected
  function updateFileLabel() {
    const input = document.getElementById('imageInput');
    const fileCount = document.getElementById('fileCount');
    
    if (input.files.length > 0) {
      fileCount.textContent = input.files.length + (input.files.length === 1 ? ' image' : ' images');
      fileCount.style.display = 'inline-block';
    } else {
      fileCount.style.display = 'none';
    }
  }
  
  // Copy message text to clipboard
  function copyMessageText(button) {
    const messageText = button.closest('.text-message').querySelector('.message-text-content').textContent;
    navigator.clipboard.writeText(messageText).then(() => {
      // Show a brief "Copied!" tooltip
      const originalTitle = button.getAttribute('title');
      button.setAttribute('title', 'Copied!');
      button.classList.add('copied');
      
      setTimeout(() => {
        button.setAttribute('title', originalTitle);
        button.classList.remove('copied');
      }, 1500);
    });
  }
  
  // Image preview functionality
  let currentImageIndex = 0;
  let galleryImages = [];
  
  function openImagePreview(event, img) {
    if (event) {
      event.stopPropagation();
    }
    
    const previewOverlay = document.getElementById('imagePreviewOverlay');
    const previewImage = document.getElementById('previewImage');
    const previewControls = document.getElementById('previewControls');
    
    // Hide controls after 1 second
    previewControls.classList.remove('hide');
    setTimeout(() => {
      previewControls.classList.add('hide');
    }, 1000);
    
    // Set the preview image
    previewImage.src = img.src;
    
    // Calculate total images and current position
    const allImages = Array.from(document.querySelectorAll('.img-thumbnail'));
    const visibleImages = allImages.filter(img => img.offsetParent !== null);
    
    // Find the index of the current image
    let currentIndex = -1;
    for (let i = 0; i < visibleImages.length; i++) {
      if (visibleImages[i].src === img.src) {
        currentIndex = i;
        break;
      }
    }
    
    // Update counter
    updateImageCounter(currentIndex, visibleImages.length);
    
    // Show the overlay
    previewOverlay.style.display = 'flex';
    document.body.style.overflow = 'hidden'; // Prevent scrolling when preview is open
    
    // Remember current state for navigation
    previewOverlay.dataset.currentIndex = currentIndex;
    previewOverlay.dataset.totalImages = visibleImages.length;
  }
  
  function updateImageCounter(currentIndex, totalImages) {
    const counter = document.getElementById('imageCounter');
    counter.textContent = `${currentIndex + 1}/${totalImages}`;
  }
  
  function navigateImage(direction, event) {
    if (event) {
      event.stopPropagation();
    }
    
    const previewOverlay = document.getElementById('imagePreviewOverlay');
    const previewImage = document.getElementById('previewImage');
    const previewControls = document.getElementById('previewControls');
    
    // Show controls and hide after 1 second
    previewControls.classList.remove('hide');
    setTimeout(() => {
      previewControls.classList.add('hide');
    }, 1000);
    
    // Get all image elements
    const allImages = Array.from(document.querySelectorAll('.img-thumbnail'));
    const visibleImages = allImages.filter(img => img.offsetParent !== null);
    
    // Get current index from dataset
    let currentIndex = parseInt(previewOverlay.dataset.currentIndex) || 0;
    const totalImages = parseInt(previewOverlay.dataset.totalImages) || visibleImages.length;
    
    // Calculate the new index
    let newIndex = currentIndex + direction;
    
    // Handle wrapping around
    if (newIndex < 0) {
      newIndex = visibleImages.length - 1;
    } else if (newIndex >= visibleImages.length) {
      newIndex = 0;
    }
    
    // Set the new image and update counter
    if (visibleImages[newIndex]) {
      previewImage.src = visibleImages[newIndex].src;
      updateImageCounter(newIndex, totalImages);
      
      // Update current index
      previewOverlay.dataset.currentIndex = newIndex;
    }
  }
  
  // Add mouse wheel navigation with reversed direction
  document.getElementById('imagePreviewOverlay').addEventListener('wheel', function(e) {
    e.preventDefault(); // Prevent page scrolling
    if (e.deltaY > 0) {
      // Scrolling down - go to previous image
      navigateImage(-1, e);
    } else {
      // Scrolling up - go to next image
      navigateImage(1, e);
    }
  });
  
  function closeImagePreview(event) {
    if (event) {
      event.stopPropagation();
    }
    
    const previewOverlay = document.getElementById('imagePreviewOverlay');
    previewOverlay.style.display = 'none';
    document.body.style.overflow = ''; // Restore scrolling
  }
  
  // Add touch swipe support for mobile
  let touchStartX = 0;
  let touchEndX = 0;
  
  function setupSwipeListeners() {
    const previewImage = document.getElementById('previewImage');
    const previewOverlay = document.getElementById('imagePreviewOverlay');
    
    // Add touch event listeners to the entire overlay for better swipe detection
    previewOverlay.addEventListener('touchstart', function(e) {
      touchStartX = e.changedTouches[0].screenX;
    }, { passive: false });
    
    previewOverlay.addEventListener('touchend', function(e) {
      touchEndX = e.changedTouches[0].screenX;
      handleSwipe(e);
    }, { passive: false });
  }
  
  // Setup swipe listeners when the DOM is loaded
  document.addEventListener('DOMContentLoaded', setupSwipeListeners);
  
  function handleSwipe(e) {
    const swipeThreshold = 50; // Minimum distance to consider as swipe
    if (touchEndX < touchStartX - swipeThreshold) {
      // Swipe left - go to next image
      navigateImage(1, e);
    } else if (touchEndX > touchStartX + swipeThreshold) {
      // Swipe right - go to previous image
      navigateImage(-1, e);
    }
  }
  
  // Add keyboard navigation
  document.addEventListener('keydown', function(e) {
    if (document.getElementById('imagePreviewOverlay').style.display === 'flex') {
      if (e.key === 'ArrowLeft') {
        navigateImage(-1, e);
      } else if (e.key === 'ArrowRight') {
        navigateImage(1, e);
      } else if (e.key === 'Escape') {
        closeImagePreview(e);
      }
      
      // Prevent default behavior for arrow keys and Escape
      if (['ArrowLeft', 'ArrowRight', 'Escape'].includes(e.key)) {
        e.preventDefault();
      }
    }
  });
  
  // Helper function for file icons
  function getFileIcon(mimetype) {
    if (mimetype.startsWith('image/')) return 'fa-file-image text-primary';
    if (mimetype === 'application/pdf') return 'fa-file-pdf text-danger';
    if (mimetype.includes('document') || mimetype.includes('word')) return 'fa-file-word text-primary';
    if (mimetype.includes('spreadsheet') || mimetype.includes('excel')) return 'fa-file-excel text-success';
    if (mimetype.includes('audio')) return 'fa-file-audio text-warning';
    if (mimetype.includes('video')) return 'fa-file-video text-danger';
    if (mimetype.includes('zip') || mimetype.includes('compressed')) return 'fa-file-archive text-warning';
    if (mimetype.includes('text/')) return 'fa-file-alt text-info';
    return 'fa-file text-secondary';
  }
  
  // Download all files in a group
  function downloadAllFiles(fileIds) {
    try {
      const ids = JSON.parse(fileIds);
      ids.forEach((id, index) => {
        // Slight delay between downloads to avoid browser blocking
        setTimeout(() => {
          window.open('/files/download/' + id, '_blank');
        }, index * 300);
      });
    } catch (e) {
      console.error('Error downloading files:', e);
    }
  }

  // Image preview functionality
  document.addEventListener('DOMContentLoaded', function() {
    const previewOverlay = document.getElementById('imagePreviewOverlay');
    const previewImage = document.getElementById('previewImage');
    
    // Handle image clicks for preview
    document.querySelectorAll('.chat-img, .image-grid-item img').forEach(img => {
      img.addEventListener('click', function(e) {
        e.preventDefault();
        const src = this.src;
        const alt = this.alt || 'Image Preview';
        openImagePreview(e, this);
      });
    });
    
    // Close preview on button click
    document.getElementById('closePreview')?.addEventListener('click', function(e) {
      closeImagePreview(e);
    });
    
    // Close preview on overlay click
    previewOverlay.addEventListener('click', function(e) {
      if (e.target === this) {
        closeImagePreview(e);
      }
    });
    
    // Handle PWA installation
    let deferredPrompt;
    const installButton = document.getElementById('installButton');
    
    window.addEventListener('beforeinstallprompt', (e) => {
      // Prevent Chrome 67 and earlier from automatically showing the prompt
      e.preventDefault();
      // Stash the event so it can be triggered later
      deferredPrompt = e;
      // Show the install button
      installButton.style.display = 'inline-block';
    });
    
    installButton.addEventListener('click', async () => {
      if (!deferredPrompt) {
        return;
      }
      // Show the installation prompt
      deferredPrompt.prompt();
      // Wait for the user to respond to the prompt
      const { outcome } = await deferredPrompt.userChoice;
      // Hide the install button regardless of outcome
      installButton.style.display = 'none';
      // We no longer need the prompt
      deferredPrompt = null;
    });
    
    // Handle iOS install prompt
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    const isInStandaloneMode = window.matchMedia('(display-mode: standalone)').matches;
    
    if (isIOS && !isInStandaloneMode && !localStorage.getItem('pwaInstallPromptShown')) {
      // Create a custom installation prompt for iOS
      const iosPrompt = document.createElement('div');
      iosPrompt.className = 'pwa-install-prompt';
      iosPrompt.innerHTML = `
        <div class="pwa-install-prompt-icon">
          <i class="fas fa-mobile-alt"></i>
        </div>
        <div class="pwa-install-prompt-text">
          <div class="pwa-install-prompt-title">Add to Home Screen</div>
          <div>Install this app on your device for quick access.</div>
          <div class="pwa-install-prompt-actions">
            <button class="btn btn-sm btn-outline-secondary" id="iosDismissBtn">Not Now</button>
            <button class="btn btn-sm btn-primary" id="iosInstallBtn">How to Install</button>
          </div>
        </div>
      `;
      document.body.appendChild(iosPrompt);
      
      // Handle iOS prompt buttons
      document.getElementById('iosDismissBtn').addEventListener('click', () => {
        iosPrompt.remove();
        localStorage.setItem('pwaInstallPromptShown', 'true');
      });
      
      document.getElementById('iosInstallBtn').addEventListener('click', () => {
        alert('To install: tap the Share button in Safari and then "Add to Home Screen"');
        localStorage.setItem('pwaInstallPromptShown', 'true');
      });
    }
    
    // Offline detection
    const offlineAlert = document.getElementById('offlineAlert');
    
    function updateOnlineStatus() {
      if (navigator.onLine) {
        offlineAlert.style.display = 'none';
      } else {
        offlineAlert.style.display = 'block';
      }
    }
    
    window.addEventListener('online', updateOnlineStatus);
    window.addEventListener('offline', updateOnlineStatus);
    updateOnlineStatus(); // Initial check
  });
  
  // Enable right-click and context menu on preview image
  document.getElementById('previewImage').addEventListener('contextmenu', function(e) {
    // Allow default context menu to enable "Copy Image"
    // This ensures the browser's native image copy functionality works
    e.stopPropagation();
    return true;
  });
  
  // Show controls when mouse moves
  document.getElementById('imagePreviewOverlay').addEventListener('mousemove', function() {
    const previewControls = document.getElementById('previewControls');
    previewControls.classList.remove('hide');
    
    // Clear any existing timeout
    if (this.timeout) clearTimeout(this.timeout);
    
    // Set a new timeout
    this.timeout = setTimeout(() => {
      previewControls.classList.add('hide');
    }, 1000);
  });
</script> 